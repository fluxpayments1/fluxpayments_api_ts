"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.matchFromAbsolutePaths = exports.createMatchPath = void 0;
const path = __importStar(require("path"));
const Filesystem = __importStar(require("./filesystem"));
const MappingEntry = __importStar(require("./mapping-entry"));
const TryPath = __importStar(require("./try-path"));
/**
 * Creates a function that can resolve paths according to tsconfig paths property.
 *
 * @param absoluteBaseUrl Absolute version of baseUrl as specified in tsconfig.
 * @param paths The paths as specified in tsconfig.
 * @param mainFields A list of package.json field names to try when resolving module files. Select a nested field using an array of field names.
 * @param addMatchAll Add a match-all "*" rule if none is present
 * @returns a function that can resolve paths.
 */
function createMatchPath(absoluteBaseUrl, paths, mainFields = ["main"], addMatchAll = true) {
    const absolutePaths = MappingEntry.getAbsoluteMappingEntries(absoluteBaseUrl, paths, addMatchAll);
    return (requestedModule, readJson, fileExists, extensions) => matchFromAbsolutePaths(absolutePaths, requestedModule, readJson, fileExists, extensions, mainFields);
}
exports.createMatchPath = createMatchPath;
/**
 * Finds a path from tsconfig that matches a module load request.
 *
 * @param absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.
 * @param requestedModule The required module name.
 * @param readJson Function that can read json from a path (useful for testing).
 * @param fileExists Function that checks for existence of a file at a path (useful for testing).
 * @param extensions File extensions to probe for (useful for testing).
 * @param mainFields A list of package.json field names to try when resolving module files. Select a nested field using an array of field names.
 * @returns the found path, or undefined if no path was found.
 */
function matchFromAbsolutePaths(absolutePathMappings, requestedModule, readJson = Filesystem.readJsonFromDiskSync, fileExists = Filesystem.fileExistsSync, extensions = Object.keys(require.extensions), mainFields = ["main"]) {
    const tryPaths = TryPath.getPathsToTry(extensions, absolutePathMappings, requestedModule);
    if (!tryPaths) {
        return undefined;
    }
    return findFirstExistingPath(tryPaths, readJson, fileExists, mainFields);
}
exports.matchFromAbsolutePaths = matchFromAbsolutePaths;
function findFirstExistingMainFieldMappedFile(packageJson, mainFields, packageJsonPath, fileExists) {
    for (let index = 0; index < mainFields.length; index++) {
        const mainFieldSelector = mainFields[index];
        const candidateMapping = typeof mainFieldSelector === "string"
            ? packageJson[mainFieldSelector]
            : mainFieldSelector.reduce((obj, key) => obj[key], packageJson);
        if (candidateMapping && typeof candidateMapping === "string") {
            const candidateFilePath = path.join(path.dirname(packageJsonPath), candidateMapping);
            if (fileExists(candidateFilePath)) {
                return candidateFilePath;
            }
        }
    }
    return undefined;
}
function findFirstExistingPath(tryPaths, readJson = Filesystem.readJsonFromDiskSync, fileExists, mainFields = ["main"]) {
    for (const tryPath of tryPaths) {
        if (tryPath.type === "file" ||
            tryPath.type === "extension" ||
            tryPath.type === "index") {
            if (fileExists(tryPath.path)) {
                return TryPath.getStrippedPath(tryPath);
            }
        }
        else if (tryPath.type === "package") {
            const packageJson = readJson(tryPath.path);
            if (packageJson) {
                const mainFieldMappedFile = findFirstExistingMainFieldMappedFile(packageJson, mainFields, tryPath.path, fileExists);
                if (mainFieldMappedFile) {
                    return mainFieldMappedFile;
                }
            }
        }
        else {
            TryPath.exhaustiveTypeException(tryPath.type);
        }
    }
    return undefined;
}
//# sourceMappingURL=match-path-sync.js.map