"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStructuredSelector = exports.createSelector = exports.createSelectorCreator = exports.defaultEqualityCheck = exports.defaultMemoize = void 0;
const defaultMemoize_1 = require("./defaultMemoize");
Object.defineProperty(exports, "defaultMemoize", { enumerable: true, get: function () { return defaultMemoize_1.defaultMemoize; } });
Object.defineProperty(exports, "defaultEqualityCheck", { enumerable: true, get: function () { return defaultMemoize_1.defaultEqualityCheck; } });
function getDependencies(funcs) {
    const dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
    if (!dependencies.every(dep => typeof dep === 'function')) {
        const dependencyTypes = dependencies
            .map(dep => typeof dep === 'function'
            ? `function ${dep.name || 'unnamed'}()`
            : typeof dep)
            .join(', ');
        throw new Error(`createSelector expects all input-selectors to be functions, but received the following types: [${dependencyTypes}]`);
    }
    return dependencies;
}
function createSelectorCreator(memoize, ...memoizeOptionsFromArgs) {
    const createSelector = (...funcs) => {
        let recomputations = 0;
        let lastResult;
        // Due to the intricacies of rest params, we can't do an optional arg after `...funcs`.
        // So, start by declaring the default value here.
        // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)
        let directlyPassedOptions = {
            memoizeOptions: undefined
        };
        // Normally, the result func or "output selector" is the last arg
        let resultFunc = funcs.pop();
        // If the result func is actually an _object_, assume it's our options object
        if (typeof resultFunc === 'object') {
            directlyPassedOptions = resultFunc;
            // and pop the real result func off
            resultFunc = funcs.pop();
        }
        if (typeof resultFunc !== 'function') {
            throw new Error(`createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`);
        }
        // Determine which set of options we're using. Prefer options passed directly,
        // but fall back to options given to createSelectorCreator.
        const { memoizeOptions = memoizeOptionsFromArgs } = directlyPassedOptions;
        // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer
        // is an array. In most libs I've looked at, it's an equality function or options object.
        // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full
        // user-provided array of options. Otherwise, it must be just the _first_ arg, and so
        // we wrap it in an array so we can apply it.
        const finalMemoizeOptions = Array.isArray(memoizeOptions)
            ? memoizeOptions
            : [memoizeOptions];
        const dependencies = getDependencies(funcs);
        const memoizedResultFunc = memoize(function recomputationWrapper() {
            recomputations++;
            // apply arguments instead of spreading for performance.
            return resultFunc.apply(null, arguments);
        }, ...finalMemoizeOptions);
        // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
        const selector = memoize(function dependenciesChecker() {
            const params = [];
            const length = dependencies.length;
            for (let i = 0; i < length; i++) {
                // apply arguments instead of spreading and mutate a local list of params for performance.
                // @ts-ignore
                params.push(dependencies[i].apply(null, arguments));
            }
            // apply arguments instead of spreading for performance.
            lastResult = memoizedResultFunc.apply(null, params);
            return lastResult;
        });
        Object.assign(selector, {
            resultFunc,
            memoizedResultFunc,
            dependencies,
            lastResult: () => lastResult,
            recomputations: () => recomputations,
            resetRecomputations: () => (recomputations = 0)
        });
        return selector;
    };
    // @ts-ignore
    return createSelector;
}
exports.createSelectorCreator = createSelectorCreator;
exports.createSelector = 
/* #__PURE__ */ createSelectorCreator(defaultMemoize_1.defaultMemoize);
// Manual definition of state and output arguments
exports.createStructuredSelector = ((selectors, selectorCreator = exports.createSelector) => {
    if (typeof selectors !== 'object') {
        throw new Error('createStructuredSelector expects first argument to be an object ' +
            `where each property is a selector, instead received a ${typeof selectors}`);
    }
    const objectKeys = Object.keys(selectors);
    const resultSelector = selectorCreator(
    // @ts-ignore
    objectKeys.map(key => selectors[key]), (...values) => {
        return values.reduce((composition, value, index) => {
            composition[objectKeys[index]] = value;
            return composition;
        }, {});
    });
    return resultSelector;
});
//# sourceMappingURL=index.js.map